const bcrypt = require('bcryptjs'); // library for hashing the password
const jwt = require('jsonwebtoken'); //jwt for authentication

const { users , tasks,myCar } = require('../constants');
const User = require('../models/user');


module.exports =  {
    Query :{
  
    users:() => users,
    user : (_,{id},{email}) => {
        console.log('=====',email);
        // if(!email){
        //     throw new Error('Access Denied! Please login to continue!');
        // }
        return users.find(user => user.id === id)}


    },

    // Defining Mutation Object -- sync with userTypeDefs
    Mutation: {  
        signup: async(_,{ input }) => {
            try{
                const user = await User.findOne({ email : input.email});
                if(user){
                    throw new Error('Email already in use');
                }
                // const hashedPassword = await bcrypt.hash(input.password,12); // hashed password bcrypt autogenerated
                const hashedPassword = await input.password; // password set by user--> anything as per user
                const newUser = new User({...input , password : hashedPassword});
                const result = await newUser.save();
                return result;
            }catch(error){
                console.log(error);
                throw error;
            }
        },
        login : async(_, {input}) => {
            try{
                const user = await User.findOne({email:input.email});
                if(!user){
                    throw new Error('User not found');
                }
                // const isPasswordValid = await bcrypt.compare(input.password,user.password);
                const isPasswordValid = input.password == user.password;
                if(!isPasswordValid){
                    throw new Error('Incorrect Password');
                }
                const secret = 'mysecretkey';
                const token = jwt.sign({ email : user.email },secret, { expiresIn : '1d' });
                // return { token : token};
                return { token };

            }catch(error){
                console.log(error);
                throw error
            }
        }
    },
    
    User: { // User == object
        tasks:({ id }) =>  //tasks == field resolver
            tasks.filter(task => task.userId === id)
    }      
};